Thread ID: 5990949
User 1230001 (Parent Post) says:
<document version="2.0"><paragraph>Hello,</paragraph><paragraph>I have been working on the k-means algorithm and have been banging my head against the same issue for the past two days and am looking for some advice/where I am going wrong. I believe it is in my implementation and would love advice.</paragraph><paragraph>So far what I believe is right: I create the array from an image, with ex. dim (412, 620, 3), which I <code>array.reshape(-1,3)</code> to vectorize into dim (255440, 3); I select x amount of points randomly to be centers, i.e. 4 points, which is (4,3). (Note: I have noticed that my dimensions are swapped in comparison to the demo code, is this the primary problem/the only problem? I feel having x rows of [R,G,B] makes sense intuitively and given lecture material.)</paragraph><paragraph>This is where I get a little stuck, as in the demo code cues to calculate the center norm which gives me a (1,k) vector and </paragraph><math>2\cdot x^T\bullet c</math><paragraph>which does not compute, as x.T has the dimensions (3, 255440). </paragraph><paragraph>Another command works to an extent: <code>np.linalg.norm(points[:,np.newaxis,:]-c,...)</code> and while I understand why this is working in terms of broadcasting, it is originally from another class, and problems still arrive with composing an image from the cluster center values. </paragraph><paragraph>Apologies for the rant, I have just been going in circles with this issue for a while; thank you for your time and I hope you are having a great weekend. </paragraph><paragraph/></document>

Answer from User 962232:
The demo code for K-Means is working with images that are grayscale, not RGB. You can still use the Euclidean distance formula for 1x3 vectors (RGB pixel) just as you can use it for a scalar (the grayscale pixel). Specifically what problems are you having? Is the output not what you are expecting?


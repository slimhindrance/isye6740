Thread ID: 5971908
User 1483727 (Parent Post) says:
<document version="2.0"><paragraph>Hi,</paragraph><paragraph>I've been working on HW 1 problem 3 and I have a few of questions. </paragraph><paragraph>First, I opted not to use the simplified minimum euclidean distance calculation like the demo code below</paragraph><pre>c2 = np.sum(np.power(centers, 2), axis=0, keepdims=True)<break/>        tmpdiff = 2 * np.dot(flatArr.T, centers) - c2</pre><paragraph>and instead use the full eculidean distance calculation using linAlg Norm (bolded in the code below). I did this as I needed to have a calculation that could be adapted for Manhattan distance. However, I'm finding that although both solutions converge, they do not converge to the same centers even with the seed set. Is that expected? Or is there an issue with the calculation? I did have to reshape the array for it to broadcast (I assume that's why the simplified form is used). So I am not sure if that's the issue. I double checked that the starting centers were the same and I can see that for the k=3 cluster, the two different methods are transposes of each other. Is this because I've broadcasted incorrectly? Or is this just coincidence</paragraph><paragraph>My second question is this  - in order to create the output image do need we set every pixel's RGB value to the value of the center of the cluster? </paragraph><paragraph>Last question, I've tried assigning pixel RGB values based on the centers, but the reconstructed is absolute nonsense. Is this potentially a result of flattening the image?</paragraph><figure><image src="https://static.us.edusercontent.com/files/1QudzEcxyEElgytc59JCmTGk" width="473" height="271"/></figure><paragraph>Sorry for the many and long questions....</paragraph><pre>import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from PIL import Image
import copy
import time


turtArray = np.array(Image.open('/sea-turtle-400x225.png'))
footArray = np.array(Image.open('/football.bmp'))
bootArray = np.array(Image.open('/booties.jpg'))


np.random.seed(7)
norm = 2

k_it = [3,6,12,24,48]

arr = turtArray[:,:,:3]
flatArr = arr.reshape(arr.shape[0]*arr.shape[1], arr.shape[2])
numPix = flatArr.shape[0]


for k in k_it:
    iterations = 1
    centers = np.random.randint(low=0,high=255,size=(k,flatArr.shape[1]))
    c_old = copy.deepcopy(centers) + 10
    #from demo code
    tic = time.time()
    while np.linalg.norm(centers - c_old, ord='fro') &gt; 1e-6:
        #from demo code
        c_old = copy.deepcopy(centers)

        <bold>distances = np.linalg.norm(flatArr[:,:,None]-centers.T, axis=1, ord=norm)</bold>

        labels = np.argmin(distances, axis =1)

        assignment  = np.zeros((labels.size, k)) 


        assignment[np.arange(labels.size), labels] = 1 
        #from https://www.geeksforgeeks.org/how-to-remove-array-rows-that-contain-only-0-using-numpy/ using to remove empty clusters. Changed code to give indices instead of boolean mask and changed axis for columns instead of rows
        nonEmptyCluster = np.where(~np.all(assignment == 0, axis=0))[0]
        assignment = assignment[:, nonEmptyCluster]


        #assignment = np.stack((np.arange(0, numPix),labels),axis=1)

        #straight from demo
        count = assignment.sum(axis=0)

        centers = centers[nonEmptyCluster,:]
        c_old = c_old[nonEmptyCluster,:]

        #adapted from demo code
        centers = (np.array(assignment.T.dot(flatArr).T / count).T).astype(int)

        iterations += 1
    flatIm = np.dot(assignment, centers)
    unflat = flatIm.reshape(arr.shape[0],arr.shape[1],3) 

    imNew = new_im = Image.fromarray(unflat, mode="RGB")
    imNew.show()

    
    

    print(k, " clusters")
    #from demo code
    toc = time.time()
    print('Elapsed time is %f seconds \n' % float(toc - tic))
    print(iterations, " iterations")
    

</pre></document>

Answer from User 799310:
These are some good questions! We can't debug or comment directly on your code/output, but can provide some guidance.



Different euclidean distance calcs and convergence: While in theory both formulas (if correct) should give the same distance values and converge identically on the same seed, it's possible that minor mathematical differences (e.g. floating point precision, array broadcasting) could accumulate and eventually lead to different convergence. That being said, you must ensure your full euclidean distance calculation is correct

Reconstructing output image: Yes, you would typically set each pixel's (R,G,B) to the (R,G,B) of its assigned cluster center

Incorrect reconstructed output: There are a few possible issues here. Ensure that the way you reshape before and after clustering is consistent, so that pixel assignments map back to the original row/column indices in the final image. In addition, just ensure that ANY filtering or reshaping you do doesn't impede your ability to correctly map a pixel back to its intended cluster center

 

  Comment from User 1483727:
  Super helpful! Thank you very much!

